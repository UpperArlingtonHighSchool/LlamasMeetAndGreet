package bc19;
public class MyRobot extends BCAbstractRobot {
	public int turn;

    public Action turn() {
    	turn++;

    	if (me.unit == SPECS.CASTLE) {
    		if(turn<3) {
    			log("ENEMY CASTLE IS AT: " + findEnemyCastle(me.x,me.y));
    			for(int x=-1;x<2;x++) {
    				for(int y=-1;y<2;y++) {
    					if(x==0&&y==0)continue;
    					if(isClear(me.x+x,me.y+y)&&fuel>49&&karbonite>9) {
    						return buildUnit(SPECS.PILGRIM,x,y);
    					}	
    				}
    			}
    		}
    	}
    	if (me.unit == SPECS.PILGRIM) {
    		if(me.karbonite<19&&fuel>5) {
    			int[] CloseKarbCords=findKarbonite(me.x,me.y);//Find closest karbonite
    			int xKarb=CloseKarbCords[0];//Store coordinates of closest Karbonite
    			int yKarb=CloseKarbCords[1];
			if(distance(me.x,me.y,xKarb,yKarb)==0){
				return mine();
			}else{
				return route(me.x,me.y,xKarb,yKarb); 
			}
		}else if(me.karbonite>18){ //If storage is full, go to castle
			int[] CloseCastleCords=findCastle(me.x,me.y);
			int xCastle=CloseCastleCords[0];
			int yCastle=CloseCastleCords[1]; 
			if(distance(me.x,me.y,xCastle,yCastle)<2){
				return give(xCastle-me.x,yCastle-me.y,me.karbonite,0);
			}else{
				return route(me.x,me.y,xCastle,yCastle);
			}
		}
    	}

    	return null;

	}
    //Will find the closest karbonite to a set of coordinates and will output an array with the coordinates of the Karb
    private int[] findKarbonite(int x1,int y1) {
    	double minDist=9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2=0;
		int y2=0;
		int[] closestCord=new int[2];
		closestCord[0]=-1;
		closestCord[1]=-1;
		for(boolean[] a: karboniteMap) {
        	         x2=0;
			 for(boolean b: a) {
				 if(b==true){ //If there is fuel
					 if(Math.pow(x2-x1,2)+Math.pow(y2-y1, 2)<minDist) {
						 minDist=Math.pow(x2-me.x,2)+Math.pow(y2-me.y, 2);
						 closestCord[0]=x2;
						 closestCord[1]=y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
		return closestCord;
    }
    private int[] findCastle(int x1, int y1) {
    	double minDist=9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2=0;
		int y2=0;
		int[] closestCord=new int[2];
		closestCord[0]=-1;
		closestCord[1]=-1;
		for(int[] a: getVisibleRobotMap()) {
        	         x2=0;
			 for(int b: a) {
				 if(b>0&&getRobot(b).team==me.team&&getRobot(b).unit==0){
					 if(Math.pow(x2-x1,2)+Math.pow(y2-y1, 2)<minDist) {
						 minDist=Math.pow(x2-me.x,2)+Math.pow(y2-me.y, 2);
						 closestCord[0]=x2;
						 closestCord[1]=y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
		return closestCord; //Returns array of length 2 of castle coordinates
    }
    private int[] findEnemyCastle(int x1, int y1) {
    	double minDist=9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2=0;
		int y2=0;
		int[] closestCord=new int[2];
		closestCord[0]=-1;
		closestCord[1]=-1;
		for(int[] a: getVisibleRobotMap()) {
        	         x2=0;
			 for(int b: a) {
				 if(b>0&&getRobot(b).team!=me.team&&getRobot(b).unit==0){
					 if(Math.pow(x2-x1,2)+Math.pow(y2-y1, 2)<minDist) {
						 minDist=Math.pow(x2-me.x,2)+Math.pow(y2-me.y, 2);
						 closestCord[0]=x2;
						 closestCord[1]=y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
		return closestCord; //Returns array of length 2 of castle coordinates
    }
    private MoveAction route(int xCo, int yCo, int xTarget, int yTarget) {
    	int xMove=xTarget-xCo;
    	int yMove=yTarget-yCo;
    	if(xMove*xMove+yMove*yMove>4) {
			if(xMove>1){xMove=1;}
			if(xMove<-1){xMove=-1;}
			if(yMove>1){yMove=1;}
			if(yMove<-1){yMove=-1;}
    	}
    	if(isClear(xCo+xMove,yCo+yMove)==false) {
    		//The path isn't passable, check alternates, find choice that get's closest to goal
    		double minDistance=9001;
    		for(int x=-1;x<2;x++) {
    			for(int y=-1;y<2;y++) {
    				if(x==0&&y==0)continue;
    				if(distance(xCo+x,yCo+y,xTarget,yTarget)<minDistance&&isClear(xCo+x,yCo+y)) {
    					minDistance=distance(xCo+x,yCo+y,xTarget,yTarget);
    					xMove=x;
    					yMove=y;
    				}
    			}
    		}
    	}
		return move(xMove,yMove);
    }
    private double distance(int x1, int y1, int x2, int y2) {
    	return Math.sqrt(Math.pow((double)x1-x2, 2)+Math.pow((double)y1-y2, 2));
    }
    //Return true if it's clear
    private boolean isClear(int x, int y) {
    	return (x>-1)&&(y>-1)&&map[y][x] && (getVisibleRobotMap()[y][x]==0);
    	
    }
}
