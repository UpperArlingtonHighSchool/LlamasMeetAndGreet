package bc19;
public class MyRobot extends BCAbstractRobot {
	public int turn;

    public Action turn() {
    	turn++;

    	if (me.unit == SPECS.CASTLE) {
    		if (turn == 1) {
    			log("Building a pilgrim.");
    			return buildUnit(SPECS.PILGRIM,1,0);
    		}
    	}

    	if (me.unit == SPECS.PILGRIM) {
    		if(me.karbonite<19&&fuel>5) {
    			int[] CloseKarbCords=findKarbonite(me.x,me.y);//Find closest karbonite
    			int xKarb=CloseKarbCords[0];//Store coordinates of closest Karbonite
    			int yKarb=CloseKarbCords[1];
			if(distance(me.x,me.y,xKarb,yKarb)==0){
				return mine();
			}else{
				int[] route=route(me.x,me.y,xKarb,yKarb); 
	        	int xRoute=route[0];
				int yRoute=route[1];
				log("TRYING TO GO: "+xRoute+" "+yRoute);
				return move(xRoute, yRoute);
			}
		}else if(me.karbonite>18){ //If storage is full, go to castle
			int[] CloseCastleCords=findCastle(me.x,me.y);
			int xCastle=CloseCastleCords[0];
			int yCastle=CloseCastleCords[1];
			int[] route=route(me.x,me.y,xCastle,yCastle); 
			int xRoute=route[0];
			int yRoute=route[1];
			log("CLOSEST CASTE IS at: "+xCastle+" "+yCastle);
			if(distance(me.x,me.y,xCastle,yCastle)<2){
				return give(xRoute,yRoute,me.karbonite,0);
			}else{
				log("TRYING TO GO: "+xRoute+" "+yRoute);
				return move(xRoute, yRoute);
			}
		}
    	}

    	return null;

	}
    //Will find the closest karbonite to a set of coordinates and will output an array with the coordinates of the Karb
    private int[] findKarbonite(int x1,int y1) {
    	double minDist=9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2=0;
		int y2=0;
		int[] closestCord=new int[2];
		closestCord[0]=-1;
		closestCord[1]=-1;
		for(boolean[] a: karboniteMap) {
        	         x2=0;
			 for(boolean b: a) {
				 if(b==true){ //If there is fuel
					 if(Distance(x1,y1,x2,y2)<minDist) {
						 minDist=Math.pow(x2-me.x,2)+Math.pow(y2-me.y, 2);
						 closestCord[0]=x2;
						 closestCord[1]=y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
		return closestCord;
    }
    private int[] findCastle(int x1, int y1) {
    	double minDist=9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2=0;
		int y2=0;
		int[] closestCord=new int[2];
		closestCord[0]=-1;
		closestCord[1]=-1;
		for(int[] a: getVisibleRobotMap()) {
        	         x2=0;
			 for(int b: a) {
				 if(b>0&&getRobot(b).team==me.team&&getRobot(b).unit==0){
					 if(distance(x1,y1,x2,y2)<minDist) {
						 minDist=Math.pow(x2-me.x,2)+Math.pow(y2-me.y, 2);
						 closestCord[0]=x2;
						 closestCord[1]=y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
		return closestCord; //Returns array of length 2 of castle coordinates
    }
     //Return the coordinates to move to to get to some coordinates. Returns array In format {x,y}.
    private int[] route(int x1, int y1, int x2, int y2) {
	//This function assumes you can only move to an adjacent square
    	int x=x2-x1;
    	int y=y2-y1;
		if(x>1){x=1;}
		if(x<-1){x=-1;}
		if(y>1){y=1;}
		if(y<-1){y=-1;}
		int route[] = {x,y};
		return route;
    }
    private double distance(int x1, int y1, int x2, int y2) {
    	return Math.sqrt(Math.pow((double)x1-x2, 2)+Math.pow((double)y1-y2, 2));
    }
}
