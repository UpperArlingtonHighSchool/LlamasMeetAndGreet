package bc19;
public class MyRobot extends BCAbstractRobot {
	public int turn;

    public Action turn() {
    	turn++;
    	
    	
    	if(me.unit == SPECS.CASTLE) {
    		if(turn == 1) {
    			log("Built crusader");
    			return buildUnit(SPECS.CRUSADER, 1, 1);
    		}
    	}
    	
    	int[] EnemyCastleCords = findEnemyCastle(me.x, me.y);
    	
    	if(me.unit == SPECS.CRUSADER) {
    		return route(me.x, me.y, EnemyCastleCords[0], EnemyCastleCords[1], 0);
    	}
    	
    	return null;
    }
    	
    	/*
    	if (me.unit == SPECS.CASTLE) {
    		if(turn<3) {
    			log("ENEMY CASTLE IS AT: " + findEnemyCastle(me.x,me.y));
    			for(int x=-1;x<2;x++) {
    				for(int y=-1;y<2;y++) {
    					if(x==0&&y==0)continue;
    					if(isClear(me.x+x,me.y+y)&&fuel>49&&karbonite>9) {
    						return buildUnit(SPECS.PILGRIM,x,y);
    					}	
    				}
    			}
    		}else if(karbonite>24&&fuel>50&&turn%5==0){
    			for(int x=-1;x<2;x++) {
    				for(int y=-1;y<2;y++) {
    					if(x==0&&y==0)continue;
    					if(isClear(me.x+x,me.y+y)&&fuel>49&&karbonite>9) {
    						return buildUnit(SPECS.PROPHET,x,y);
    					}	
    				}
    			}
    		}
    	}
    	if (me.unit==SPECS.PROPHET) {
    		int[] EnemyCords=findEnemyCastle(me.x,me.y);
    		int xCord=EnemyCords[0];
    		int yCord=EnemyCords[1];
    		if(xCord==0&&yCord==0) {//Try moving somewhere randomly if you cannot find the castle
    			int i=0;
    			while(i<20) {
    				xCord=(int)(Math.random()*6-3);
    				yCord=(int)(Math.random()*6-3);
    				if(xCord*xCord+yCord*yCord<5&&isClear(me.x+xCord,me.y+yCord)) {
    					return move(xCord, yCord);
    				}
    				i++;
    			}
    		}
    		if(distance(me.x,me.y,xCord,yCord)<9&&distance(me.x,me.y,xCord,yCord)>3) {//Attack if within range
    			return attack(xCord-me.x,yCord-me.y);
    		}
    	}
    	if (me.unit == SPECS.PILGRIM) {
    		if(me.karbonite>18||me.fuel>90){ //If storage is full, go to castle
				int[] CloseCastleCords=findCastle(me.x,me.y);
				int xCastle=CloseCastleCords[0];
				int yCastle=CloseCastleCords[1]; 
				if(distance(me.x,me.y,xCastle,yCastle)<2){
					return give(xCastle-me.x,yCastle-me.y,me.karbonite,me.fuel);
				}else{
					return route(me.x,me.y,xCastle,yCastle,1);
				}
			}
    		if(me.karbonite>0||fuel>300) {//If you have enough fuel, find some carbonite or if you've already started mining
    			int[] CloseKarbCords=findKarbonite(me.x,me.y);//Find closest karbonite
    			int xKarb=CloseKarbCords[0];//Store coordinates of closest Karbonite
    			int yKarb=CloseKarbCords[1];
    			if(distance(me.x,me.y,xKarb,yKarb)==0){
    				return mine();
    			}else{
    				return route(me.x,me.y,xKarb,yKarb,0); 
    			}
    		}
    			int[] CloseFuelCords=findFuel(me.x,me.y);//Find closest fuel
    			int xFuel=CloseFuelCords[0];//Store coordinates of closest fuel
    			int yFuel=CloseFuelCords[1];
    			if(distance(me.x,me.y,xFuel,yFuel)==0){
    				return mine();
    			}else{
    				return route(me.x,me.y,xFuel,yFuel,0); 
    			}
    	}

    	return null;

	}
    //Will find the closest karbonite to a set of coordinates and will output an array with the coordinates of the Karb
    
    
    
    
    */
    private int[] findKarbonite(int x1,int y1) {
    	double minDist=9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2=0;
		int y2=0;
		int[] closestCord=new int[2];
		closestCord[0]=0;
		closestCord[1]=0;
		for(boolean[] a: karboniteMap) {
        	 x2=0;
			 for(boolean b: a) {
				 if(b==true){ //If there is karbonite
					 if(distance(me.x,me.y,x2,y2)<minDist) {
						 minDist=distance(me.x,me.y,x2,y2);
						 closestCord[0]=x2;
						 closestCord[1]=y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
		return closestCord;
    }
    private int[] findFuel(int x1,int y1) {
    	double minDist=9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2=0;
		int y2=0;
		int[] closestCord=new int[2];
		closestCord[0]=0;
		closestCord[1]=0;
		for(boolean[] a: fuelMap) {
        	 x2=0;
			 for(boolean b: a) {
				 if(b==true){ //If there is fuel
					 if(distance(me.x,me.y,x2,y2)<minDist) {
						 minDist=distance(me.x,me.y,x2,y2);
						 closestCord[0]=x2;
						 closestCord[1]=y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
		return closestCord;
    }
    private int[] findCastle(int x1, int y1) {
    	double minDist = 9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2 = 0;
		int y2 = 0;
		int[] closestCord = new int[2];
		closestCord[0] = -1;
		closestCord[1] = -1;
		for(int[] a: getVisibleRobotMap()) {
        	 x2 = 0;
			 for(int b : a) {
				 if(b > 0 && getRobot(b).team == me.team && getRobot(b).unit == 0){
					 if(distance(x1,y1,x2,y2) < minDist) {
						 minDist = distance(x1,y1,x2,y2);
						 closestCord[0] = x2;
						 closestCord[1] = y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
		return closestCord; //Returns array of length 2 of castle coordinates
    }
    
    
    private AttackAction crusaderAttack(int x, int y) {
    	double minDist = 9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2 = 0;
		int y2 = 0;
		int xLength = 0;
		int yLength = 0;
		int[] closeEnemy = new int[2];
		closeEnemy[0] = 0;
		closeEnemy[1] = 0;
		for(int[] a : getVisibleRobotMap()) {
        	 x2 = 0;
			 for(int b : a) {
				 if(b > 0 && getRobot(b).team != me.team && getRobot(b).unit == 0){
					 if(distance(me.x,me.y,x2,y2)<minDist) {
						 minDist = distance(me.x,me.y,x2,y2);
						 closeEnemy[0] = x2;
						 closeEnemy[1] = y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
    	
		xLength = closeEnemy[0] - x;
		yLength = closeEnemy[1] - y;
				
		if(Math.abs(xLength) > 4 || Math.abs(yLength) > 4) {
			return null;
		}
		if(Math.abs(xLength) == 4 && Math.abs(yLength) == 0) {
			return attack(xLength, 0);
		}
		if(Math.abs(yLength) == 4 && Math.abs(xLength) == 0) {
			return attack(0, yLength);
		}
		if((Math.abs(xLength) + Math.abs(yLength)) < 5) {
			return attack(xLength, yLength);
		}
		
    	return null;
    }
    
    private AttackAction preacherAttack(int x, int y) {
    	double minDist = 9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2 = 0;
		int y2 = 0;
		int xLength = 0;
		int yLength = 0;
		int[] closeEnemy = new int[2];
		closeEnemy[0] = 0;
		closeEnemy[1] = 0;
		for(int[] a : getVisibleRobotMap()) {
        	 x2 = 0;
			 for(int b : a) {
				 if(b > 0 && getRobot(b).team != me.team && getRobot(b).unit == 0){
					 if(distance(me.x,me.y,x2,y2)<minDist) {
						 minDist = distance(me.x,me.y,x2,y2);
						 closeEnemy[0] = x2;
						 closeEnemy[1] = y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
    	
		xLength = closeEnemy[0] - x;
		yLength = closeEnemy[1] - y;
				
		if(Math.abs(xLength) > 4 || Math.abs(yLength) > 4) {
			return null;
		}
		if(Math.abs(xLength) == 4 && Math.abs(yLength) == 0) {
			return attack(xLength, 0);
		}
		if(Math.abs(yLength) == 4 && Math.abs(xLength) == 0) {
			return attack(0, yLength);
		}
		if((Math.abs(xLength) + Math.abs(yLength)) < 5) {
			return attack(xLength, yLength);
		}
		
    	return null;
    }
    
    
    private AttackAction prophetAttack(int x, int y) {
    	double minDist = 9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2 = 0;
		int y2 = 0;
		int xLength = 0;
		int yLength = 0;
		int[] closeEnemy = new int[2];
		closeEnemy[0] = 0;
		closeEnemy[1] = 0;
		for(int[] a : getVisibleRobotMap()) {
        	 x2 = 0;
			 for(int b : a) {
				 if(b > 0 && getRobot(b).team != me.team && getRobot(b).unit == 0){
					 if(distance(me.x,me.y,x2,y2)<minDist) {
						 minDist = distance(me.x,me.y,x2,y2);
						 closeEnemy[0] = x2;
						 closeEnemy[1] = y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
    	
		xLength = closeEnemy[0] - x;
		yLength = closeEnemy[1] - y;
				
		if(Math.abs(xLength) == 3 && Math.abs(yLength) == 3) {
			return attack(xLength, yLength);
		}
		if(Math.abs(xLength) <= 3) {
			return null;
		}
		if(Math.abs(yLength) <= 3) {
			return null;
		}
		if(Math.abs(xLength) == 8 && Math.abs(yLength) == 0) {
			return attack(xLength, yLength);
		}
		if(Math.abs(yLength) == 8 && Math.abs(xLength) == 0) {
			return attack(xLength, yLength);
		}
		if((Math.abs(xLength) + Math.abs(yLength)) < 11) {
			return attack(xLength, yLength);
		}
		
    	return null;
    }
    
    
    private int[] findEnemyCastle(int x1, int y1) {
    	double minDist=9001; //IT's OVER NINE THOUSAND!!!!!!!!!!!!
    	int x2=0;
		int y2=0;
		int[] closestCord=new int[2];
		closestCord[0]=0;
		closestCord[1]=0;
		for(int[] a: getVisibleRobotMap()) {
        	 x2=0;
			 for(int b: a) {
				 if(b > 0 && getRobot(b).team != me.team && getRobot(b).unit == 0){
					 if(distance(me.x,me.y,x2,y2)<minDist) {
						 minDist=distance(me.x,me.y,x2,y2);
						 closestCord[0]=x2;
						 closestCord[1]=y2;
					 }
				 }
			  x2++;
			 }
        	 y2++;
        
		}
		return closestCord; //Returns array of length 2 of castle coordinates
    }
    
    
    
    
    
    
    private MoveAction route(int xCo, int yCo, int xTarget, int yTarget, int dist) {
    	int xMove=xTarget-xCo;
    	int yMove=yTarget-yCo;
    	if(xMove*xMove+yMove*yMove>4) {
			if(xMove>1){xMove=1;}
			if(xMove<-1){xMove=-1;}
			if(yMove>1){yMove=1;}
			if(yMove<-1){yMove=-1;}
    	}
    	if(isClear(xCo+xMove,yCo+yMove)==false) {
    		//The path isn't passable, check alternates, find choice that get's closest to goal
    		double minDistance=9001;
    		for(int x=-2;x<3;x++) {
    			for(int y=-2;y<3;y++) {
    				if((x==0&&y==0)||(x*x+y*y>4))continue;
    				if(isClear(xCo+x,yCo+y)) {
    					if(dist==1&&distance(xCo+x,yCo+y,xTarget,yTarget)==1) {
    						return move(x,y);
    					}
    					//Think two moves in advance
    					for(int x2=-2;x2<3;x2++) {
    		    			for(int y2=-2;y2<3;y2++) {
    		    				if((x2==0&&y2==0)||(x2*x2+y2*y2>4))continue;
    		    				if(distance(xCo+x+x2,yCo+y+y2,xTarget,yTarget)<minDistance&&isClear(xCo+x+x2,yCo+y+y2)) {
    		    					minDistance=distance(xCo+x+x2,yCo+y+y2,xTarget,yTarget);
    		    					xMove=x;
    		    					yMove=y;
    		    				}
    		    			}
    					}
    					
    				}
    			}
    		}
    	}
		return move(xMove,yMove);
    }
    private double distance(int x1, int y1, int x2, int y2) {
    	return Math.sqrt(Math.pow((double)x1-x2, 2)+Math.pow((double)y1-y2, 2));
    }
    //Return true if it's clear
    private boolean isClear(int x, int y) {
    	return (x>-1)&&(y>-1)&&(x<map[0].length)&&(y<map.length)&&map[y][x] && (getVisibleRobotMap()[y][x]==0);
    	
    }
}
